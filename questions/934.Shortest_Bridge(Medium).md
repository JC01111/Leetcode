## 934. Shortest Bridge (Medium)
**Date and Time:** Apr 28, 2025

Link: https://leetcode.com/problems/shortest-bridge

<br>

### Walk-through: 
1. Traverse `grid` to find the first entry `1` of island 1. Then we can run DFS on this entry to find its neighbors, which all belong to island 1. We add these entries to `deque[]` and change value to `2` so we won't revisit later. <br> <br> Be careful when we traverse `grid`, we only want to find the first entry of `1`, so stop after we found it.

2. Run BFS on `deque[]`, we maintain a variable `cnt`, each time we process one layer of BFS, we increment cnt, if a entry's neighbor is `1`, we should return `cnt` right away. Else, if the neighbor is `0`, we add it to `deque[]` and change the value to `2` as well.

<br>

### Python Solution:
```python
class Solution:
    def shortestBridge(self, grid: List[List[int]]) -> int:
        # Q: Find smallest # of 0 we need to flip to connect two islands
        # S: 1. Loop over grid to find the first 1, then start running dfs on this entry, and mark all this island's entries to be 2 (distinguish with island 2). Add these entries to deque[] for later BFS with cnt = 0
        # 2. Use BFS for all entries of island 1, if any entry's neighbors is 1, return cnt. Else, check four directions and append new entry with cnt+1 into deque
        # TC: O(n^2), n=len(grid), SC: O(n^2)

        deque = collections.deque()
        n = len(grid)
        # 1. Find all entries of island 1 and change them to be 2
        directions = [[-1, 0], [1, 0], [0, 1], [0, -1]]
        # Add entry to deque[] and change 1 to 2
        def dfs(r, c):
            deque.append([r, c])
            grid[r][c] = 2
            for dr, dc in directions:
                row, col = r+dr, c+dc
                if row in range(n) and col in range(n) and grid[row][col] == 1:
                    dfs(row, col)
        # Find island 1 with dfs
        found = False
        for r in range(n):
            for c in range(n):
                if grid[r][c] == 1:
                    dfs(r, c)
                    found = True
                    break
            if found:
                break
        # 2. Use BFS for deque to find the smallest flip
        cnt = 0
        while deque:
            for _ in range(len(deque)):
                r, c = deque.popleft()
                for dr, dc in directions:
                    row, col = r+dr, c+dc
                    if row in range(n) and col in range(n):
                        # Check if grid[row][col] is 1 (island 2)
                        if grid[row][col] == 1:
                            print(f"{row}{col}")
                            return cnt
                        # If entry is 0, we can add into deque and change to 2 (avoid revisiting)
                        elif grid[row][col] == 0:
                            deque.append([row, col])
                            grid[row][col] = 2
            cnt += 1
```
**Time Complexity:** $O(n^2)$ <br>
**Space Complexity:** $O(n^2)$

<br>

<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1" alt="CC BY-NC-SA" title="CC BY-NC-SA"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" alt="BY: credit must be given to the creator" title="BY: credit must be given to the creator"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1" alt="NC: Only noncommercial uses of the work are permitted" title="NC: Only noncommercial uses of the work are permitted"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1" alt="SA: Adaptations must be shared under the same terms" title="SA: Adaptations must be shared under the same terms">