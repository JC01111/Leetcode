## 3531. Count Covered Buildings (Medium)
**Date and Time:** Apr 26, 2025

Link: https://leetcode.com/problems/count-covered-buildings

<br>

### Walk-through: 
1. Use row, col dictionaries to save each pt's `r`, `c`. `rows: {r: [cols]}`, `cols: {c: [rows]}`. Every point with the same `r`, I will save their `c` into `rows` dictionary, same thing for `cols`.

2. Sort `rows, cols`, so later we can use binary search to find pts.

3. For each pt, we apply binary search to find each pt's `(r, c)`, we first check `r` on `cols[c]`, find its index, then we check if `index > 0` so we know `r`'s left exists in `cols[c]`, check if `index < len(cols[c] -1 )` to know `r`'s right exists in `cols[c]`. Same thing to check this pt's top and bottom.

<br>

### Python Solution:
```python
class Solution:
    def countCoveredBuildings(self, n: int, buildings: List[List[int]]) -> int:
        # Q: Find # of covered buildings
        # S: 1. Save every point into col and row dictionaries row: {row: [cols(y)]}, col: {col: [rows(x)]}
        # 2. Loop over each point again, check if its four directions, if there exists at least one pt on these directions
        # TC: O(nlogn), SC: O(n)
        
        # 1. Save pt into col, row{}
        cols, rows = collections.defaultdict(list), collections.defaultdict(list)
        for r, c in buildings:
            cols[c].append(r)
            rows[r].append(c)
        # Sort rows, cols
        for c, row_list in cols.items():
            row_list.sort()
        for r, col_list in rows.items():
            col_list.sort()
        
        # 2. Check each pt again and check their four directions
        ans = 0
        for r, c in buildings:
            # Check its four directions by binary search on r, c
            # If we can find index of r, c, we can know if there exists less/greater value than r, c
            idx_r = bisect_left(cols[c], r)
            left = idx_r > 0
            right = idx_r < len(cols[c]) - 1
            
            idx_c = bisect_left(rows[r], c)
            top = idx_c > 0
            bot = idx_c < len(rows[r]) - 1
                    
            if left and right and top and bot:
                ans += 1
        return ans
```
**Time Complexity:** $O(nlog(n))$ <br>
**Space Complexity:** $O(n)$

<br>

<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1" alt="CC BY-NC-SA" title="CC BY-NC-SA"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" alt="BY: credit must be given to the creator" title="BY: credit must be given to the creator"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1" alt="NC: Only noncommercial uses of the work are permitted" title="NC: Only noncommercial uses of the work are permitted"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1" alt="SA: Adaptations must be shared under the same terms" title="SA: Adaptations must be shared under the same terms">