## 1976. Number of Ways to Arrive at Destination (Medium)
**Date and Time:** Mar 24, 2025

Link: https://leetcode.com/problems/number-of-ways-to-arrive-at-destination

<br>

### Edge Cases:

**Edge Case 1:**
> **Input:** n = 1, roads = [] <br>
> **Output:** 1 <br>
> **Explanation:** There is one way to get node `0`

<br>

### Walk-through: 
1. Build the undirected graph

2. Run Dijkstra to find the shortest path with a list for `dist` (keep track of the time to reach each node), `path_cnt` for how many path to reach a node. 

Relaxation: If current time + neighbor's time less than the current time we have on `dist[]`, we update the time and the number of path to reach this node to `dist[node]` (current node we at). If the new time equals to the time we have already, update the `path_cnt[nei]` with current counts and the prev node's count, so we can update how many ways we can reach at the destination with the same shortest time.

<br>

### Python Solution:
```python
class Solution:
    def countPaths(self, n: int, roads: List[List[int]]) -> int:
        # Find the min time from 0 to n-1. Return # ways to reach the min time
        # Run Dijkstra's from source to n-1
        # TC: O(E + Elog(V)), E is total edges, V is n, SC: O(V)

        # Build graph
        graph = collections.defaultdict(list)
        for u, v, t in roads:
            graph[u].append((v, t))
            graph[v].append((u, t))
        # Run Dijkstra's
        dist = [0] + [float("inf")] * (n-1)
        path_cnt = [1] + [0] * (n-1)
        minHeap = [(0, 0)]     # [(time, node)]
        while minHeap:
            time, node = heapq.heappop(minHeap)
            # If new time is less than prev time in dist for current node
            if time <= dist[node]:
                for nei, nei_time in graph[node]:
                    # If new time is smaller, update dist[nei]
                    if time + nei_time < dist[nei]:
                        dist[nei] = time + nei_time
                        path_cnt[nei] = path_cnt[node]
                        heapq.heappush(minHeap, [dist[nei], nei])
                    # Alternate way to reach the same time
                    elif time + nei_time == dist[nei]:
                        path_cnt[nei] = (path_cnt[nei] + path_cnt[node]) % (10**9 + 7)
        return path_cnt[n-1]
```
**Time Complexity:** $O(Elog(V))$ <br>
**Space Complexity:** $O(V)$

<br>

<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1" alt="CC BY-NC-SA" title="CC BY-NC-SA"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" alt="BY: credit must be given to the creator" title="BY: credit must be given to the creator"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1" alt="NC: Only noncommercial uses of the work are permitted" title="NC: Only noncommercial uses of the work are permitted"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1" alt="SA: Adaptations must be shared under the same terms" title="SA: Adaptations must be shared under the same terms">